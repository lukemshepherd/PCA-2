{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vox This is a package for rotating, aligning and plotting voxel or stl bone objects. Repository link Documentation","title":"Home"},{"location":"#vox","text":"This is a package for rotating, aligning and plotting voxel or stl bone objects.","title":"Vox"},{"location":"#repository-link","text":"","title":"Repository link"},{"location":"#documentation","text":"","title":"Documentation"},{"location":"about/","text":"Questions If you have questions about","title":"Questions"},{"location":"about/#questions","text":"If you have questions about","title":"Questions"},{"location":"documentation/","text":"Documentation Bone class methods .get_xyz(self) Convert 3D voxel array to xyz coordinates. array (np.array): 3D voxel array filter_level (int/float): (inherited from bone class) sets the threshold level for what is considered a voxel. Everything below filter level is rounded to 0, everything above rounded to 1 (ie voxel) returns: np.array([n x 3]) .get_pca(self) Performs PCA on the xyz points array xyz(np.array) : n x 3 array of xyz coordinates return (self.pc1 self.pc2 self.pc3) .get_mean(self) Gets the mean xyz coordinates for xyz array return ( np.mean(self.xyz[:, 0]), np.mean(self.xyz[:, 1]), np.mean(self.xyz[:, 2]), .center_to_origin(self) Sets the mean of the bone to (0,0,0) .reset_position(self) Returns bone to original position in space .plot(self, user_color=None, PCA_inv=None, PCA=True) Plot voxels with optional PCA, and colours user_color (tuple): RGB color of the bone where 1 is maxium eg: red = (1,0,0) www.colortools.net/color_mixer.html is a good tool to work out what the best colour to use is. PCA (boolean): plots the PCAs of the voxel PCA_inv (boolean): plots the inverse of each PCA so the axes go in both directions .scale(self, n) n = scale factor scales the voxel data array by n xyz_to_array(self. array_dim=(256,256,256)) Creates a numpy voxel array the size of array_dim from .xyz attribute. array_dim list/tupple (1x3) return vx_array Functions mag(v) v = vector (np.array 1x3) Finds magnitude of vector angle (v1, v2) v1, v2 = vector (np.array 1x3) Finds the angel between two vectors return ang, v1 quaternion_rotation_from_angle(v, c_axis, theta) v = vector (np.array 1x3) c_axis = cross product between two principle conponets theta = angle of rotation (radians) rotate(bone_f1, bone_f2, interpolate=False, scale_factor=2) Aligns and rotates bone_f1 to bone_f2 bone_f1, bone_f2 = bone class object interpolate = (boolean) if True bone_f1 is upscaled, rotated and downscaled to increase point density. scale_factor = set how much the bone will be upscaled to increase the density.","title":"Documentation"},{"location":"documentation/#documentation","text":"","title":"Documentation"},{"location":"documentation/#bone-class-methods","text":"","title":"Bone class methods"},{"location":"documentation/#get_xyzself","text":"Convert 3D voxel array to xyz coordinates. array (np.array): 3D voxel array filter_level (int/float): (inherited from bone class) sets the threshold level for what is considered a voxel. Everything below filter level is rounded to 0, everything above rounded to 1 (ie voxel) returns: np.array([n x 3])","title":".get_xyz(self)"},{"location":"documentation/#get_pcaself","text":"Performs PCA on the xyz points array xyz(np.array) : n x 3 array of xyz coordinates return (self.pc1 self.pc2 self.pc3)","title":".get_pca(self)"},{"location":"documentation/#get_meanself","text":"Gets the mean xyz coordinates for xyz array return ( np.mean(self.xyz[:, 0]), np.mean(self.xyz[:, 1]), np.mean(self.xyz[:, 2]),","title":".get_mean(self)"},{"location":"documentation/#center_to_originself","text":"Sets the mean of the bone to (0,0,0)","title":".center_to_origin(self)"},{"location":"documentation/#reset_positionself","text":"Returns bone to original position in space","title":".reset_position(self)"},{"location":"documentation/#plotself-user_colornone-pca_invnone-pcatrue","text":"Plot voxels with optional PCA, and colours user_color (tuple): RGB color of the bone where 1 is maxium eg: red = (1,0,0) www.colortools.net/color_mixer.html is a good tool to work out what the best colour to use is. PCA (boolean): plots the PCAs of the voxel PCA_inv (boolean): plots the inverse of each PCA so the axes go in both directions","title":".plot(self, user_color=None, PCA_inv=None, PCA=True)"},{"location":"documentation/#scaleself-n","text":"n = scale factor scales the voxel data array by n","title":".scale(self, n)"},{"location":"documentation/#xyz_to_arrayself-array_dim256256256","text":"Creates a numpy voxel array the size of array_dim from .xyz attribute. array_dim list/tupple (1x3) return vx_array","title":"xyz_to_array(self. array_dim=(256,256,256))"},{"location":"documentation/#functions","text":"","title":"Functions"},{"location":"documentation/#magv","text":"v = vector (np.array 1x3) Finds magnitude of vector","title":"mag(v)"},{"location":"documentation/#angle-v1-v2","text":"v1, v2 = vector (np.array 1x3) Finds the angel between two vectors return ang, v1","title":"angle (v1, v2)"},{"location":"documentation/#quaternion_rotation_from_anglev-c_axis-theta","text":"v = vector (np.array 1x3) c_axis = cross product between two principle conponets theta = angle of rotation (radians)","title":"quaternion_rotation_from_angle(v, c_axis, theta)"},{"location":"documentation/#rotatebone_f1-bone_f2-interpolatefalse-scale_factor2","text":"Aligns and rotates bone_f1 to bone_f2 bone_f1, bone_f2 = bone class object interpolate = (boolean) if True bone_f1 is upscaled, rotated and downscaled to increase point density. scale_factor = set how much the bone will be upscaled to increase the density.","title":"rotate(bone_f1, bone_f2, interpolate=False, scale_factor=2)"},{"location":"get_started/","text":"How to use Set custom filter level (optional) bone.filter_level = 0.1 Set custom colour for bone (optional) tibia_f1.default_color = (0.8, 0.3, 0) 1. Load the data that you want to use tibia_f2 = bone.from_matlab_path(matlab_file='phantom/phantom_tibia_f2.mat') tibia_f1 = bone.from_matlab_path(matlab_file='phantom/phantom_tibia_f1.mat') 2. Rotate the bone voxel_rotate(tibia_f1, tibia_f2) 3. Plotting the rotation tibia_f1.plot() tibia_f2.plot() mlab.show() Plotting with mayavi is very similar to matplotplib where you build a scene and call it with show() You can plot bones by calling the .plot() method and then mlab.show() 4. Table of Angles df_angles(tibia_f1, tibia_f2, name='tibia')","title":"Getting started"},{"location":"get_started/#how-to-use","text":"","title":"How to use"},{"location":"get_started/#set-custom-filter-level-optional","text":"bone.filter_level = 0.1","title":"Set custom filter level (optional)"},{"location":"get_started/#set-custom-colour-for-bone-optional","text":"tibia_f1.default_color = (0.8, 0.3, 0)","title":"Set custom colour for bone (optional)"},{"location":"get_started/#1-load-the-data-that-you-want-to-use","text":"tibia_f2 = bone.from_matlab_path(matlab_file='phantom/phantom_tibia_f2.mat') tibia_f1 = bone.from_matlab_path(matlab_file='phantom/phantom_tibia_f1.mat')","title":"1. Load the data that you want to use"},{"location":"get_started/#2-rotate-the-bone","text":"voxel_rotate(tibia_f1, tibia_f2)","title":"2. Rotate the bone"},{"location":"get_started/#3-plotting-the-rotation","text":"tibia_f1.plot() tibia_f2.plot() mlab.show() Plotting with mayavi is very similar to matplotplib where you build a scene and call it with show() You can plot bones by calling the .plot() method and then mlab.show()","title":"3. Plotting the rotation"},{"location":"get_started/#4-table-of-angles","text":"df_angles(tibia_f1, tibia_f2, name='tibia')","title":"4. Table of Angles"},{"location":"install/","text":"How to install Clone git repo $ git pull https://github.com/lukemshepherd/vox.git $ cd vox Create conda environment $ conda env create -f environment.yml $ conda activate vox Create vox package $ pip install -e . Installing packages individually Python Python 3.6 and higher mayavi mayavi install docs Mayavi plots images by calling the VTK library and displaying it a qt window- this means it is very very fast, however can be a bit of pain to install. Part of this is caused by its ability to work with different qt packages, which makes it very flexible but does also mean it can get a bit confused! You can use conda to install it but using pip seems to be easier and will sort out the VTK install for you. $ pip install mayavi $ pip install PyQt5 numpy-quaternion Numpy doesn't natively support quaternions as a data type- this package allows you to pass quaternions properly and makes multiplication and returning the imaginary component a lot easier. numpy-quaternion github numpy-quaternion docs $ conda install -c conda-forge quaternion or $ pip install numpy-quaternion numpy-stl Numpy-stl adds support for loading and breaking down stl data. numpy-stl github numpy-stl documentation $ pip install numpy-stl","title":"Installing"},{"location":"install/#how-to-install","text":"","title":"How to install"},{"location":"install/#clone-git-repo","text":"$ git pull https://github.com/lukemshepherd/vox.git $ cd vox","title":"Clone git repo"},{"location":"install/#create-conda-environment","text":"$ conda env create -f environment.yml $ conda activate vox","title":"Create conda environment"},{"location":"install/#create-vox-package","text":"$ pip install -e .","title":"Create vox package"},{"location":"install/#installing-packages-individually","text":"","title":"Installing packages individually"},{"location":"install/#python","text":"Python 3.6 and higher","title":"Python"},{"location":"install/#mayavi","text":"mayavi install docs Mayavi plots images by calling the VTK library and displaying it a qt window- this means it is very very fast, however can be a bit of pain to install. Part of this is caused by its ability to work with different qt packages, which makes it very flexible but does also mean it can get a bit confused! You can use conda to install it but using pip seems to be easier and will sort out the VTK install for you. $ pip install mayavi $ pip install PyQt5","title":"mayavi"},{"location":"install/#numpy-quaternion","text":"Numpy doesn't natively support quaternions as a data type- this package allows you to pass quaternions properly and makes multiplication and returning the imaginary component a lot easier. numpy-quaternion github numpy-quaternion docs $ conda install -c conda-forge quaternion or $ pip install numpy-quaternion","title":"numpy-quaternion"},{"location":"install/#numpy-stl","text":"Numpy-stl adds support for loading and breaking down stl data. numpy-stl github numpy-stl documentation $ pip install numpy-stl","title":"numpy-stl"},{"location":"interpolation/","text":"Voxel Interpolation What is the issue When you rotate the bone the out puts are decimals which cant be put back into the voxel array by upscaling the voxel more of the coordinates are integers and so reduces the resolution loss when converting back into an array.","title":"Interpolation"},{"location":"interpolation/#voxel-interpolation","text":"","title":"Voxel Interpolation"},{"location":"interpolation/#what-is-the-issue","text":"When you rotate the bone the out puts are decimals which cant be put back into the voxel array by upscaling the voxel more of the coordinates are integers and so reduces the resolution loss when converting back into an array.","title":"What is the issue"},{"location":"stl/","text":"STL files STL objects are treated pretty much the same as normal voxel objects. They can be rotated/plotted etc. Also they can be used with voxel ones- i.e you can rotate an stl by a voxel. Loading data: tibia_stl = bone.from_stl_path(stl_file='phantom/phantom_tibia_f2.stl') How the data is stored The full stl data is stored in tibia_stl.data The stl files are loaded from numpy-stl module Saving bones back into .stl tibia_stl.data.save('file.stl')","title":"STL objects"},{"location":"stl/#stl-files","text":"STL objects are treated pretty much the same as normal voxel objects. They can be rotated/plotted etc. Also they can be used with voxel ones- i.e you can rotate an stl by a voxel.","title":"STL files"},{"location":"stl/#loading-data","text":"tibia_stl = bone.from_stl_path(stl_file='phantom/phantom_tibia_f2.stl')","title":"Loading data:"},{"location":"stl/#how-the-data-is-stored","text":"The full stl data is stored in tibia_stl.data The stl files are loaded from numpy-stl module","title":"How the data is stored"},{"location":"stl/#saving-bones-back-into-stl","text":"tibia_stl.data.save('file.stl')","title":"Saving bones back into .stl"}]}